package us.mudkip989.plugins.bge.game.object;

import org.bukkit.*;
import org.bukkit.inventory.*;
import org.bukkit.util.Vector;
import org.joml.*;
import us.mudkip989.plugins.bge.dataTypes.*;
import us.mudkip989.plugins.bge.util.*;

import java.lang.Math;
import java.util.*;

public class BasicButton extends Object {

    public hitbox bounding;

    public BasicButton(Matrix4f transformation, World w, UUID game, hitbox hb) {
        super(transformation, w, game);
        bounding = hb;
    }

    @Override
    public void teleport(Matrix4f trans, World w) {

    }

    public RaycastResult raycastToObject(Vector3f pos, Vector3f dir, World dim){
        if(!dim.equals(world)){
            return new RaycastResult(new Vector3f(0, 0, 0), 0, false);
        }
        dir.normalize();
        //convert to transformation

        Matrix4f result = new Matrix4f();
        Matrix4f inverse = new Matrix4f(getWorldSpaceTransform()).invert();

        Vector3f newStartPos = inverse.transformPosition(new Vector3f(pos));
        Vector3f newDir = inverse.transformDirection(new Vector3f(dir));





//        Matrix4f rayTransform = TransformUtils.getTransform(new Location(dim, pos.x, pos.y, pos.z).setDirection(new Vector(dir.x, dir.y, dir.z)));
//        AxisAngle4f intermediate = new AxisAngle4f();
//        inverse.mul(rayTransform, result);
//        //set new raycast vars
//        result.getTranslation(newStartPos);
//        result.getRotation(intermediate);
//        intermediate.transform(new Vector3f(0, 0, 1), newDir);

        //Grab vector scale
        float scaled = newDir.length();
        newDir.normalize();
        //define bounds
        float minX = bounding.center().x - bounding.size().x/2;
        float maxX = bounding.center().x + bounding.size().x/2;
        float minY = bounding.center().y - bounding.size().y/2;
        float maxY = bounding.center().y + bounding.size().y/2;
        float minZ = bounding.center().z - bounding.size().z/2;
        float maxZ = bounding.center().z + bounding.size().z/2;

        // r.dir is unit direction vector of ray
        Vector3f dirfrac = new Vector3f();

        //Divide by 0 check (This snippet was generated by AI, but it does show me how to use the ? operator. I will not count this as the project being AI Generated because of this.)
        final float EPSILON = 1e-6f;
        dirfrac.x = Math.abs(newDir.x) < EPSILON ? Float.POSITIVE_INFINITY : 1f / newDir.x;
        dirfrac.y = Math.abs(newDir.y) < EPSILON ? Float.POSITIVE_INFINITY : 1f / newDir.y;
        dirfrac.z = Math.abs(newDir.z) < EPSILON ? Float.POSITIVE_INFINITY : 1f / newDir.z;


        // lb is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner
        // r.org is origin of ray
        float t1 = (minX - newStartPos.x)*dirfrac.x;
        float t2 = (maxX - newStartPos.x)*dirfrac.x;
        float t3 = (minY - newStartPos.y)*dirfrac.y;
        float t4 = (maxY - newStartPos.y)*dirfrac.y;
        float t5 = (minZ - newStartPos.z)*dirfrac.z;
        float t6 = (maxZ - newStartPos.z)*dirfrac.z;

        float tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
        float tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
        float t = 0;
        boolean success = true;
        // if tmax < 0, ray (line) is intersecting AABB, but the whole AABB is behind us
        if (tmax < 0)
        {
            t = tmax;
            success = false;
        //            return false;
        }

        // if tmin > tmax, ray doesn't intersect AABB
        if (tmin > tmax)
        {
            t = tmax;
            success = false;
        //            return false;
        }

        //Now checks for success
        if(success) {
            t = tmin;
        }

        //Use t for getting end location and distance
        Vector3f endPoint = pos.add(dir.mul(t*scaled, new Vector3f()), new Vector3f());



        return new RaycastResult(endPoint, dir.mul(t*scaled, new Vector3f()).length(), success);
    }

}
